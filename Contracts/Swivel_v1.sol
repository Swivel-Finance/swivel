pragma solidity ^0.5.9;
pragma experimental ABIEncoderV2;

import "./safeMath.sol";

contract Erc20 {
	function approve(address, uint) external returns (bool);
	function transfer(address, uint) external returns (bool);
	function balanceOf(address _owner) external returns (uint256 balance);
	function transferFrom(address sender, address recipient, uint256 amount) public returns (bool);
}

contract CErc20 is Erc20 {
	function mint(uint) external returns (uint);
	function redeem(uint redeemTokens) external returns (uint);
	function redeemUnderlying(uint redeemAmount) external returns (uint);
	function exchangeRateCurrent() external returns (uint);
}

contract CEth {
	function mint() external payable;
	function redeem(uint redeemTokens) external returns (uint);
	function balanceOf(address _owner) external returns (uint256 balance);
	function approve(address spender, uint tokens) public returns (bool success);
	function redeemUnderlying(uint redeemAmount) external returns (uint);
	function exchangeRateCurrent() external returns (uint);
}

contract DefiHedge {
	
struct RPCSig{
	uint8 v;
	bytes32 r;
	bytes32 s;
    }
    
struct EIP712Domain {
	string  name;
	string  version;
	uint256 chainId;
	address verifyingContract;
    }
    
///Order structure used for maker signature verification (signed off-chain)	
struct makerOrder {
	address maker;
	uint256 side;
	address tokenAddress;
	uint256 duration;
	uint256 rate;
	uint256 interest;
	uint256 principal;
	uint256 makerNonce;
	uint256 expiryTime;
	bytes32 makerOrderKey;
    }
    
///Order structure for orders maker mapping
struct activeMakerOrder {
	address maker;
	uint256 side;
	address tokenAddress;
	uint256 duration;
	uint256 rate;
	uint256 interest;
	uint256 principal;
	uint256 state;
	uint256 initialRate;
	uint256 expiryTime;
	bytes32 makerOrderKey;
    }
    
    
struct activeTakerOrder {
	address maker;
	address taker;
	uint256 side;
	address tokenAddress;
	uint256 duration;
	uint256 rate;
	uint256 interest;
	uint256 principal;
	uint256 state;
	uint256 lockTime;
	uint256 initialRate;
	bytes32 takerOrderKey;
}    
    
/// makerOrderMapping 
/// @param 
/// makerOrderKey: Hash generated by maker to identify order
/// @return
mapping(bytes32 => activeMakerOrder) public orderMapping;

/// list of all maker orders (likely unnecessary?)
/// @param 
/// uint: order in list
bytes32[] public makerList;

/// Mapping containing a list of takers for a given maker order
/// @param 
/// makerOrderKey: Hash generated by maker to identify order
mapping(bytes32 => bytes32[]) public takerListMapping;

/// Nested mapping to create a takerOrderMapping that is connected to a maker
/// @param 
/// makerOrderKey: Hash generated by maker to identify order
/// takerOrderKey: Hash generated by maker to identify order
mapping(bytes32 => mapping(bytes32 => activeTakerOrder)) takerMapping;

/// The amount of taker asset filled.
/// @param Order hash
mapping (bytes32 => uint256) public filled;

/// Whether the order was cancelled.
/// @param Order hash
mapping (bytes32 => bool) public cancelled;
    
event newLockedOrder(
	address maker,
	address taker,
	uint256 side,
	address tokenAddress,
	uint256 duration,
	uint256 rate,
	uint256 interest,
	uint256 principal,
	bytes32 makerOrderKey,
	bytes32 takerOrderKey
);
    
event Cancelled(
	bytes32 makerOrderKey
);
        
event orderReleased(
    bytes32 makerOrderKey,
	bytes32 takerOrderKey
);
    

using SafeMath for uint;

constructor () public {
	DOMAIN_SEPARATOR = hashDomain(EIP712Domain({
		name: "DefiHedge",
		version: '1',
		chainId: 3,
		verifyingContract: 0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC
}));
}
    
bytes32 DOMAIN_SEPARATOR;
    
// Offer + EIP Domain Hash Schema
bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(
	"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
);

bytes32 constant OFFER_TYPEHASH = keccak256(
	"Offer(address maker,address taker,uint256 side,address tokenAddress,uint256 duration,uint256 rate,uint256 interest,uint256 principal)"
);
    
function hashDomain(EIP712Domain memory eip712Domain) internal pure returns (bytes32) {
	return keccak256(abi.encode(
		EIP712DOMAIN_TYPEHASH,
		keccak256(bytes(eip712Domain.name)),
		keccak256(bytes(eip712Domain.version)),
		eip712Domain.chainId,
		eip712Domain.verifyingContract
        ));
}
    
function hashOrder(makerOrder memory _order)private pure returns(bytes32){
	return keccak256(abi.encode(
		OFFER_TYPEHASH,
		_order.maker,
		_order.side,
		_order.tokenAddress,
		_order.duration,
		_order.rate,
		_order.interest,
		_order.principal
	));
}
    
    
/// Returns all order details (mapping error when public?)
/// @param
/// makerOrderKey: off-chain key generated as keccak hash of User + time + nonce
/// takerOrderKey: off-chain key generated as keccak hash of User + time + nonce
function getActiveOffer(bytes32 makerOrderKey,bytes32 takerOrderKey)
public
view
returns (address maker, address taker, uint256 side, address tokenAddress, uint256 duration, uint256 rate, uint256 principal, uint256 interest, uint256 state, uint256 lockTime, uint256 initialRate)
{
	maker = takerMapping[makerOrderKey][takerOrderKey].maker;
	side = takerMapping[makerOrderKey][takerOrderKey].side;
	tokenAddress = takerMapping[makerOrderKey][takerOrderKey].tokenAddress;
	duration = takerMapping[makerOrderKey][takerOrderKey].duration;
	rate = takerMapping[makerOrderKey][takerOrderKey].rate;
	interest = takerMapping[makerOrderKey][takerOrderKey].interest;
	principal = takerMapping[makerOrderKey][takerOrderKey].principal;
	state = takerMapping[makerOrderKey][takerOrderKey].state;
	lockTime = takerMapping[makerOrderKey][takerOrderKey].lockTime;
	initialRate = takerMapping[makerOrderKey][takerOrderKey].initialRate;
        
	return (maker, taker, side, tokenAddress, duration, rate, principal, interest, state, lockTime, initialRate);
}
    
	
///Settle an entire maker order's volume
///@param
///_makerOrder: maker's order
///bytes32: off-chain key generated as keccak hash of User + time + nonce
function orderSettle(makerOrder memory _makerOrder, bytes32 takerOrderKey) private returns (bool){
	    
	    
	activeMakerOrder memory _activeMakerOrder;
	activeTakerOrder memory _activeTakerOrder;
	    
	CErc20 cToken = CErc20(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C); //DAI cToken Address

	// Check trades side
	// Transfers funds to Swivel contract
	Erc20 underlying = Erc20(_makerOrder.tokenAddress);
	if (_makerOrder.side == 0) {
		require(underlying.transferFrom(_makerOrder.maker, address(this), _makerOrder.principal), "Transfer Failed!");
		require(underlying.transferFrom(msg.sender, address(this), _makerOrder.interest), "Transfer Failed!");
	}
	if (_makerOrder.side == 1) {
		require(underlying.transferFrom(_makerOrder.maker, address(this), _makerOrder.interest), "Transfer Failed!");
		require(underlying.transferFrom(msg.sender, address(this), _makerOrder.principal), "Transfer Failed!");
	}
    	    
	// Mint CToken from DefiHedge contract
	mintCToken(_makerOrder.tokenAddress,_makerOrder.interest.add(_makerOrder.principal));
            
	// Instantiate makerOrder
	_activeMakerOrder.maker = _makerOrder.maker;
	_activeMakerOrder.side = _makerOrder.side;
	_activeMakerOrder.tokenAddress = _makerOrder.tokenAddress;
	_activeMakerOrder.duration = _makerOrder.duration;
	_activeMakerOrder.rate = _makerOrder.rate;
	_activeMakerOrder.interest = _makerOrder.interest;
	_activeMakerOrder.principal = _makerOrder.principal;
	_activeMakerOrder.state = 1;
	_activeMakerOrder.initialRate = cToken.exchangeRateCurrent();
	_activeMakerOrder.expiryTime = 0;
	_activeMakerOrder.makerOrderKey = _makerOrder.makerOrderKey;
    	    
	// Instantiate takerOrder
	_activeTakerOrder.maker = _makerOrder.maker;
	_activeTakerOrder.taker = msg.sender;
	_activeTakerOrder.side = _makerOrder.side;
	_activeTakerOrder.tokenAddress = _makerOrder.tokenAddress;
	_activeTakerOrder.duration = _makerOrder.duration;
	_activeTakerOrder.rate = _makerOrder.rate;
	_activeTakerOrder.interest = _makerOrder.interest;
	_activeTakerOrder.principal = _makerOrder.principal;
	_activeTakerOrder.state = 1;
	_activeTakerOrder.lockTime = now.add(_makerOrder.duration);
	_activeTakerOrder.initialRate = cToken.exchangeRateCurrent();
	_activeTakerOrder.takerOrderKey= takerOrderKey;
    	    
    	        
    // Store maker order
	orderMapping[_makerOrder.makerOrderKey] = _activeMakerOrder;
    // Store taker order	    
	takerMapping[_makerOrder.makerOrderKey][takerOrderKey]= _activeTakerOrder;
    	    
	// Push maker order to larger list (unnecessary)
	makerList.push(_makerOrder.makerOrderKey);
	// Push taker order to a list mapped to a given maker's order
	takerListMapping[_makerOrder.makerOrderKey].push(takerOrderKey);
	    
	emit newLockedOrder(_activeTakerOrder.maker,msg.sender,_activeTakerOrder.side,_activeTakerOrder.tokenAddress,
	_activeTakerOrder.duration,_activeTakerOrder.rate,_activeTakerOrder.interest,_activeTakerOrder.principal,_makerOrder.makerOrderKey,takerOrderKey);
    	    
	return true;
}
	
///Fill the entirety of a maker order's volume
/// @param
/// _makerOrder: maker's order 
/// takerOrderKey: off-chain key generated as keccak hash of User + time + nonce
/// makerSignature:signature associated with order param
function fillOffer(makerOrder memory _makerOrder, bytes32 takerOrderKey,bytes memory makerSignature) 	public returns (uint256){
	    
	//Check if order already partially filled
	require(orderMapping[_makerOrder.makerOrderKey].state != 1, "Order Already Partial/Fully Filled");

	//Check if order has been cancelled
	require(cancelled[_makerOrder.makerOrderKey]==false, "Order Has Been Cancelled");

	//Check if order has already expired
	require(orderMapping[_makerOrder.makerOrderKey].expiryTime >= now, "Order Has Expired");


	// Parse signature into R,S,V                        
	RPCSig memory RPCsig = signatureRPC(makerSignature);

	// Validate offer signature & ensure it was created by maker
	require(_makerOrder.maker == ecrecover(
	keccak256(abi.encodePacked(
			"\x19\x01",
			DOMAIN_SEPARATOR,
			hashOrder(_makerOrder)
			)),
			RPCsig.v,
			RPCsig.r,
			RPCsig.s), 
	"Invalid Signature");

	// Settle Response
	orderSettle(_makerOrder,takerOrderKey);

}
	
	
/// @param
/// _makerOrder: maker's order 
/// takerVolume: amount of currency being taken
/// takerOrderKey: off-chain key generated as keccak hash of User + time + nonce
/// makerSignature: signature associated with order param
/// Fill partial maker order 
function partialFillOffer(makerOrder memory _makerOrder,uint256 takerVolume, bytes32 takerOrderKey, bytes memory makerSignature ) public returns (uint256){


	//Check if order has been cancelled
	require(cancelled[_makerOrder.makerOrderKey]==false, "Order Has Been Cancelled");

	//Check if order has already expired
	require(_makerOrder.expiryTime >= now, "Order Has Expired");

	// Parse signature into R,S,V                        
	RPCSig memory RPCsig = signatureRPC(makerSignature);

	// Validate offer signature & ensure it was created by maker
	require(_makerOrder.maker == ecrecover(
		keccak256(abi.encodePacked(
			"\x19\x01",
			DOMAIN_SEPARATOR,
			hashOrder(_makerOrder)
			)),
			RPCsig.v,
			RPCsig.r,
			RPCsig.s), 
	"Invalid Signature");


	// Settle Response
	partialOrderSettle(_makerOrder, takerVolume, takerOrderKey);

}
    
    
///Settle part of a maker order's volume
///@param
///_makerOrder: makers order to fill
///takerVolume: amount of currency being taken
///takerOrderKey: off-chain key generated as keccak hash of User + time + nonce
function partialOrderSettle(makerOrder memory _makerOrder,uint256 takerVolume, bytes32 takerOrderKey) private returns (bool){

	activeMakerOrder memory _activeMakerOrder;
	activeTakerOrder memory _activeTakerOrder;
	
	CErc20 cToken = CErc20(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C); //DAI cToken Address


	//If order is fixed-side, ensure volume is less than expected interest
	if (_makerOrder.side == 0) {

		require (takerVolume <= (_makerOrder.interest), "Taker Volume > Maker");

		// if order has already been partially filled
		if (orderMapping[_makerOrder.makerOrderKey].state != 0) {
		
			require (takerVolume <= (_makerOrder.interest - filled[_makerOrder.makerOrderKey]), "Taker Volume > Available");
			
		}
		//calculate taker % of total maker order and set opposing param 
		uint256 orderRatio = (((takerVolume).mul(100000000000000000000000000)).div(_makerOrder.interest)).div(100000000000000000000000000);
		_activeTakerOrder.principal=_makerOrder.principal.mul(orderRatio);
		_activeTakerOrder.interest=takerVolume;
	}

	//If order is floating-side, ensure volume is less than expected principal
	if (_makerOrder.side == 1) {

		require (takerVolume <= (_makerOrder.principal), "Taker Volume > Maker");

		// if order has already been partially filled
		if (orderMapping[_makerOrder.makerOrderKey].state != 0) {

		require (takerVolume <= (_makerOrder.principal - filled[_makerOrder.makerOrderKey]), "Taker Volume > Available");
		}
		
		//calculate taker % of total maker order and set opposing param 
		uint256 orderRatio = (((takerVolume).mul(100000000000000000000000000)).div(_makerOrder.principal)).div(100000000000000000000000000);
		_activeTakerOrder.interest= _makerOrder.interest.mul(orderRatio);
		_activeTakerOrder.principal=takerVolume;
	}

	// Check order side
	// Transfers funds to Swivel contract
	Erc20 underlying = Erc20(_activeTakerOrder.tokenAddress);
	if (_activeTakerOrder.side == 0) {
		require(underlying.transferFrom(_activeTakerOrder.maker, address(this), _activeTakerOrder.principal), "Transfer Failed!");
		require(underlying.transferFrom(msg.sender, address(this), _activeTakerOrder.interest), "Transfer Failed!");
	}
	if (_activeTakerOrder.side == 1) {
		require(underlying.transferFrom(_activeTakerOrder.maker, address(this), _activeTakerOrder.interest), "Transfer Failed!");
		require(underlying.transferFrom(msg.sender, address(this), _activeTakerOrder.principal), "Transfer Failed!");
	}

	// Mint CToken from DefiHedge contract
	mintCToken(_activeTakerOrder.tokenAddress,_activeTakerOrder.interest.add(_activeTakerOrder.principal));


	// After mint success fill order params & store takerOrder in takerMapping
	_activeTakerOrder.maker=_makerOrder.maker;
	_activeTakerOrder.taker=msg.sender;
	_activeTakerOrder.side=_makerOrder.side;
	_activeTakerOrder.tokenAddress=_makerOrder.tokenAddress;
	_activeTakerOrder.duration=_makerOrder.duration;
	_activeTakerOrder.rate=_makerOrder.rate;
	_activeTakerOrder.state = 1;  /// Set state to active
	_activeTakerOrder.lockTime = now.add(_activeTakerOrder.duration); /// Set locktime
	_activeTakerOrder.initialRate = cToken.exchangeRateCurrent();  /// Get initial exchange rate
	_activeTakerOrder.takerOrderKey=takerOrderKey;
	
	takerMapping[_makerOrder.makerOrderKey][_activeTakerOrder.takerOrderKey]= _activeTakerOrder;


	// Instantiate & store makerOrder if this is first fill
	if (orderMapping[_makerOrder.makerOrderKey].maker == address(0x0000000000000000000000000000000000000000)) {

		_activeMakerOrder.maker = _makerOrder.maker;
		_activeMakerOrder.side = _makerOrder.side;
		_activeMakerOrder.tokenAddress = _makerOrder.tokenAddress;
		_activeMakerOrder.duration = _makerOrder.duration;
		_activeMakerOrder.rate = _makerOrder.rate;
		_activeMakerOrder.interest = _makerOrder.interest;
		_activeMakerOrder.principal = _makerOrder.principal;
		_activeMakerOrder.state = 1; /// Set state to active
		_activeMakerOrder.initialRate = _activeTakerOrder.initialRate; /// Get initial exchange rate
		_activeMakerOrder.expiryTime = _makerOrder.expiryTime;
		_activeMakerOrder.makerOrderKey = _makerOrder.makerOrderKey;

		orderMapping[_makerOrder.makerOrderKey] = _activeMakerOrder;
	}


	//push makerOrderKey to general order list (for testing)
	makerList.push(_makerOrder.makerOrderKey);

	//push takerOrderKey to takerOrderList nested in mapping
	takerListMapping[_makerOrder.makerOrderKey].push(_activeTakerOrder.takerOrderKey);



    /// Stack to deep, need to remove variables
    /// emit newLockedOrder(_activeTakerOrder.maker,_activeTakerOrder.taker,_activeTakerOrder.side,_activeTakerOrder.tokenAddress,_activeTakerOrder.duration,_activeTakerOrder.rate,_activeTakerOrder.interest,
    ///_activeTakerOrder.principal,_makerOrder.makerOrderKey,_activeTakerOrder.takerOrderKey);

	return true;	    	    
}
    
///Cancel an order
///@param
///_makerOrder: maker's order
///makerOrderKey: off-chain key generated as keccak hash of User + time + nonce
///makerSignature: maker's unseparated signature
function cancelOrder(makerOrder memory _makerOrder, bytes32 makerOrderKey, bytes memory makerSignature) public returns(bool){

	// Parse signature into R,S,V                        
	RPCSig memory RPCsig = signatureRPC(makerSignature);

	// Validate offer signature & ensure it was created by maker
	require(msg.sender == ecrecover(
		keccak256(abi.encodePacked(
		"\x19\x01",
		DOMAIN_SEPARATOR,
		hashOrder(_makerOrder)
		)),
		RPCsig.v,
		RPCsig.r,
		RPCsig.s), 
	"Invalid Signature");

	cancelled[makerOrderKey] = true;


	return true;
}
    
    
/// Release an Erc bond once if term completed
///@param
///makerOrderKey: off-chain key generated as keccak hash of User + time + nonce
///takerOrderKey: off-chain key generated as keccak hash of User + time + nonce
function releaseErcOrder(bytes32 makerOrderKey, bytes32 takerOrderKey)
public
returns(uint256){

	// Require swap state to be active
	// Require swap duration to have expired
	require(takerMapping[makerOrderKey][takerOrderKey].state == 1, "Invalid State");
	require(now >= takerMapping[makerOrderKey][takerOrderKey].lockTime, "Invalid Time");

	CErc20 cToken = CErc20(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C);
	Erc20 underlying = Erc20(orderMapping[makerOrderKey].tokenAddress);

	// Logic for a floating-side maker
	if (orderMapping[makerOrderKey].side == 1 ) {

		// Calculate annualized interest-rate generated by the swap agreement
		uint total = takerMapping[makerOrderKey][takerOrderKey].principal.add(takerMapping[makerOrderKey][takerOrderKey].interest);
		uint yield = ((cToken.exchangeRateCurrent().mul(100000000000000000000000000)).div(takerMapping[makerOrderKey][takerOrderKey].initialRate)).sub(100000000000000000000000000);
		uint annualizedRate = ((yield.mul(31536000)).div(orderMapping[makerOrderKey].duration));

		// In order to avoid subtraction underflow, ensures subtraction of smaller annualized rate
		if (orderMapping[makerOrderKey].rate > annualizedRate) {

			// Calculates difference between annualized expected rate / real rate 
			uint rateDifference = (orderMapping[makerOrderKey].rate).sub(annualizedRate);

			// Calculates differential in expected currency from previous rate differential
			uint annualFloatingDifference = (rateDifference.mul(total)).div(100000000000000000000000000);

			// De-annualizes the differential for the given time period
			uint floatingDifference = (annualFloatingDifference.div(31536000)).mul(orderMapping[makerOrderKey].duration);

			// Calculates difference between value and expected interest
			uint floatingReturned = (takerMapping[makerOrderKey][takerOrderKey].interest).sub(floatingDifference);

			// Redeems appropriate CTokens
			redeemCToken(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C,(total.add(floatingReturned)));

			// Returns funds to appropriate parties
			underlying.transfer(orderMapping[makerOrderKey].maker, floatingReturned);
			underlying.transfer(takerMapping[makerOrderKey][takerOrderKey].taker, total);

		}

		if (annualizedRate > orderMapping[makerOrderKey].rate) {
			uint rateDifference = annualizedRate.sub(orderMapping[makerOrderKey].rate);
			uint annualFloatingDifference = (rateDifference.mul(total)).div(100000000000000000000000000);
			uint floatingDifference = (annualFloatingDifference.div(31536000)).mul(orderMapping[makerOrderKey].duration);
			uint floatingReturned = (orderMapping[makerOrderKey].interest).add(floatingDifference);

			redeemCToken(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C,(total.add(floatingReturned)));

			underlying.transfer(orderMapping[makerOrderKey].maker, floatingReturned);
			underlying.transfer(takerMapping[makerOrderKey][takerOrderKey].taker, total);
			}

		if (annualizedRate == orderMapping[makerOrderKey].rate) {

			redeemCToken(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C,(total.add(orderMapping[makerOrderKey].interest)));
			
			underlying.transfer(orderMapping[makerOrderKey].maker, takerMapping[makerOrderKey][takerOrderKey].interest);
			underlying.transfer(takerMapping[makerOrderKey][takerOrderKey].taker, total);
		}
	}

	// Logic for a fixed-side maker
	if (orderMapping[makerOrderKey].side == 0 ) {

		// Calculate annualized interest-rate generated by the swap agreement
		uint total = takerMapping[makerOrderKey][takerOrderKey].principal.add(takerMapping[makerOrderKey][takerOrderKey].interest);
		uint yield = ((cToken.exchangeRateCurrent().mul(100000000000000000000000000)).div(takerMapping[makerOrderKey][takerOrderKey].initialRate)).sub(100000000000000000000000000);
		uint annualizedRate = ((yield.mul(31536000)).div(orderMapping[makerOrderKey].duration));

		// In order to avoid subtraction underflow, ensures subtraction of smaller annualized rate
		if (orderMapping[makerOrderKey].rate > annualizedRate) {

			// Calculates difference between annualized expected rate / real rate 
			uint rateDifference = (orderMapping[makerOrderKey].rate).sub(annualizedRate);

			// Calculates differential in expected currency from previous rate differential
			uint annualFloatingDifference = (rateDifference.mul(total)).div(100000000000000000000000000);

			// De-annualizes the differential for the given time period
			uint floatingDifference = (annualFloatingDifference.div(31536000)).mul(orderMapping[makerOrderKey].duration);

			// Calculates difference between value and expected interest
			uint floatingReturned = (takerMapping[makerOrderKey][takerOrderKey].interest).sub(floatingDifference);

			// Redeems appropriate CTokens
			redeemCToken(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C,(total.add(floatingReturned)));

			// Returns funds to appropriate parties
			underlying.transfer(orderMapping[makerOrderKey].maker, total);
			underlying.transfer(takerMapping[makerOrderKey][takerOrderKey].taker, floatingReturned);
		}

		if (annualizedRate > orderMapping[makerOrderKey].rate) {
			uint rateDifference = annualizedRate.sub(orderMapping[makerOrderKey].rate);
			uint annualFloatingDifference = (rateDifference.mul(total)).div(100000000000000000000000000);
			uint floatingDifference = (annualFloatingDifference.div(31536000)).mul(orderMapping[makerOrderKey].duration);
			uint floatingReturned = (orderMapping[makerOrderKey].interest).add(floatingDifference);

			redeemCToken(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C,(total.add(floatingReturned)));

			underlying.transfer(orderMapping[makerOrderKey].maker, total);
			underlying.transfer(takerMapping[makerOrderKey][takerOrderKey].taker, floatingReturned);
		}

		if (annualizedRate == orderMapping[makerOrderKey].rate) {

			redeemCToken(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C,(total.add(orderMapping[makerOrderKey].interest)));

			underlying.transfer(orderMapping[makerOrderKey].maker, total);
			underlying.transfer(takerMapping[makerOrderKey][takerOrderKey].taker, takerMapping[makerOrderKey][takerOrderKey].interest);
		}
	}

	// Change state to Expired
	takerMapping[makerOrderKey][takerOrderKey].state = 2;

	emit orderReleased(makerOrderKey,takerOrderKey);

	return(orderMapping[makerOrderKey].state);				
}
	
/// Mint cToken
function mintCToken(
address _erc20Contract,
uint _numTokensToSupply) 
internal returns (uint) {
        
	Erc20 underlying = Erc20(_erc20Contract);

	CErc20 cToken = CErc20(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C);

	// Approve transfer on the ERC20 contract
	underlying.approve(0xdb5Ed4605C11822811a39F94314fDb8F0fb59A2C, _numTokensToSupply);


	uint mintResult = cToken.mint(_numTokensToSupply);

	return mintResult;
}
    	    
/// Redeem cToken
function redeemCToken(
address _cErc20Contract, uint _numTokensToRedeem) internal {
CErc20(_cErc20Contract).redeemUnderlying(_numTokensToRedeem);
}
	
// Splits signature into RSV
function signatureRPC(bytes memory sig)internal pure returns (RPCSig memory RPCsig){
	bytes32 r;
	bytes32 s;
	uint8 v;

	if (sig.length != 65) {
		return RPCSig(0,'0','0');
	}

	assembly {
	r := mload(add(sig, 32))
	s := mload(add(sig, 64))
	v := and(mload(add(sig, 65)), 255)
	}

	if (v < 27) {
		v += 27;
	}

	if (v == 39 || v == 40) {
		v = v-12;
	}

	if (v != 27 && v != 28) {
		return RPCSig(0,'0','0');
	}

	return RPCSig(v,r,s);
	}

}
